---
const { title, testimonials, readMoreText, showLessText } = Astro.props;

interface Props {
  title: string;
  testimonials: {
    text: string;
    author: string;
    role: string;
  }[];
  readMoreText: string;
  showLessText: string;
}
---

<section id="testimonials" class="py-16 bg-white">
  <div class="container">
    <div class="text-center mb-8">
      <h2 class="blueFont text-3xl font-bold">{title}</h2>
    </div>

    <!-- Narrow the slider itself to 75% on desktop -->
    <div class="mx-auto w-full md:w-3/4">
      <div class="relative">

        <!-- Arrows (desktop-friendly). On mobile, swipe still works. -->
        <button
          type="button"
          id="t-prev"
          class="hidden md:inline-flex absolute -left-14 top-1/2 -translate-y-1/2 h-12 w-12 items-center justify-center rounded-full border-2 border-[#193472] bg-white text-[#193472] shadow-md hover:bg-[#193472] hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
          aria-label="Previous testimonial"
        >
          ❮
        </button>

        <button
          type="button"
          id="t-next"
          class="hidden md:inline-flex absolute -right-14 top-1/2 -translate-y-1/2 h-12 w-12 items-center justify-center rounded-full border-2 border-[#193472] bg-white text-[#193472] shadow-md hover:bg-[#193472] hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
          aria-label="Next testimonial"
        >
          ❯
        </button>

        <!-- Track -->
        <ul
          id="t-track"
          class="flex overflow-x-auto snap-x snap-mandatory scroll-smooth gap-6 pb-2 [-ms-overflow-style:none] [scrollbar-width:none]"
          aria-label="Testimonials slider"
        >
          <!-- Hide scrollbar (webkit) -->
          <style>
            #t-track::-webkit-scrollbar { display: none; }
          </style>

          {testimonials.map((t, index) => (
            <li class="w-full flex-shrink-0 snap-start">
              <div class="testimonial-box bg-gray-50 p-8 rounded-lg shadow-sm max-w-full flex flex-col h-full">
                <div class="testimonial-content-wrapper flex-1 overflow-hidden">
                  <div class="testimonial-text space-y-2">
                    <p class="text-gray-600">
                      {t.text}
                    </p>
                    
                    {/* Expandable logic placeholder if needed, current JSON structure assumes single text block. 
                        If we want 'read more', we'd need to truncate text or have logic. 
                        For now, restoring base design. If text is long, it will just show. 
                        Wait! The original had logic to split text or show 'read more'. 
                        Since we are using dynamic props, let's implement a simple character count clamp for now 
                        OR simply replicate the structure and let user request advanced logic if needed.
                        
                        Original code had:
                        <p>...</p>
                        <span class="testimonial-expandable">... <button>Read more</button></span>
                        
                        To keep it dynamic, we'll check length.
                    */}
                  </div>
                </div>
                
                <div class="testimonial-footer border-t border-gray-300 pt-6 mt-6">
                  <div class="flex items-center justify-center gap-3">
                    <div class="w-12 h-12 rounded-full bg-[#193472] flex items-center justify-center flex-shrink-0">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                      </svg>
                    </div>
                    <h3 class="text-xl text-center font-bold">
                       {t.author} - {t.role}
                    </h3>
                  </div>
                </div>
              </div>
            </li>
          ))}
        </ul>

        <!-- Dots -->
        <div id="t-dots" class="mt-6 flex items-center justify-center gap-2" aria-label="Testimonial pagination"></div>
      </div>
    </div>
  </div>

  <script>
    // Infinite carousel logic with seamless looping
    const initCarousel = () => {
      const track = document.getElementById("t-track");
      const prevBtn = document.getElementById("t-prev") as HTMLButtonElement;
      const nextBtn = document.getElementById("t-next") as HTMLButtonElement;
      const dotsWrap = document.getElementById("t-dots");

      if (!track || !prevBtn || !nextBtn || !dotsWrap) return;

      // Get original slides
      // Filter out clones if we re-run this script (though in Astro scripts run once per load usually)
      const existingClones = track.querySelectorAll('[data-clone]');
      existingClones.forEach(el => el.remove());

      const originalSlides = Array.from(track.querySelectorAll("li"));
      const total = originalSlides.length;

      if (total === 0) return;

      // Clone first and last slides for infinite effect
      const firstClone = originalSlides[0].cloneNode(true) as HTMLElement;
      const lastClone = originalSlides[total - 1].cloneNode(true) as HTMLElement;
      
      firstClone.setAttribute("data-clone", "first");
      lastClone.setAttribute("data-clone", "last");
      
      track.appendChild(firstClone);
      track.insertBefore(lastClone, originalSlides[0]);

      // Get all slides including clones
      const allSlides = Array.from(track.querySelectorAll("li")) as HTMLElement[];
      const realIndexOffset = 1; // Because we prepended the last clone

      // Calculate real index from slide position
      const getRealIndex = (slideIndex: number) => {
        if (slideIndex === 0) return total - 1; // Last clone
        if (slideIndex === allSlides.length - 1) return 0; // First clone
        return slideIndex - realIndexOffset; // Real slides
      };

      // Calculate slide index from real index
      const getSlideIndex = (realIndex: number) => {
        return realIndex + realIndexOffset;
      };

      let realIndex = 0;
      let isTransitioning = false;
      let isRepositioning = false;
      let lastScrollLeft = track.scrollLeft;
      let scrollDirection = 0; // 1 = forward, -1 = backward

      // Initialize: scroll to first real slide (not the cloned last one)
      const initializeCarousel = () => {
        const firstRealSlideIndex = getSlideIndex(0);
        // Important: Use instant scroll for initialization
        allSlides[firstRealSlideIndex].scrollIntoView({ behavior: "auto", inline: "start", block: "nearest" });
        realIndex = 0;
        lastScrollLeft = track.scrollLeft;
        updateUI();
      };

      const buildDots = () => {
        dotsWrap.innerHTML = "";
        // We use originalSlides length for dots
        for (let i = 0; i < total; i++) {
          const b = document.createElement("button");
          b.type = "button";
          b.className =
            "h-2.5 w-2.5 rounded-full transition-colors " +
            (i === realIndex ? "bg-[#193472]" : "bg-gray-300 hover:bg-gray-400");
          b.setAttribute("aria-label", `Go to testimonial ${i + 1} of ${total}`);
          b.addEventListener("click", () => goTo(i));
          dotsWrap.appendChild(b);
        }
      };

      const updateUI = () => {
        buildDots();
        prevBtn.disabled = false;
        nextBtn.disabled = false;
      };

      const goTo = (targetRealIndex: number, smooth = true) => {
        if (isTransitioning) return;
        
        const wrappedIndex = ((targetRealIndex % total) + total) % total; 
        
        // Determine if we're wrapping around
        let targetSlideIndex;
        let needsReposition = false;
        
        // Optimization: Check logical wrapping
        if (wrappedIndex === 0 && realIndex === total - 1) {
          // Going forward from last to first
          targetSlideIndex = allSlides.length - 1; // First clone (at the end)
          needsReposition = true;
        } else if (wrappedIndex === total - 1 && realIndex === 0) {
          // Going backward from first to last
          targetSlideIndex = 0; // Last clone (at the beginning)
          needsReposition = true;
        } else {
          // Normal navigation
          targetSlideIndex = getSlideIndex(wrappedIndex);
        }
        
        realIndex = wrappedIndex;
        isTransitioning = true;
        
        allSlides[targetSlideIndex].scrollIntoView({ 
          behavior: smooth ? "smooth" : "auto", 
          inline: "start", 
          block: "nearest" 
        });
        
        updateUI();
        
        // Handle silent repositioning for infinite effect
        if (smooth && needsReposition) {
          setTimeout(() => {
            isRepositioning = true;
            // Get the target real slide's position
            const finalTargetIndex = getSlideIndex(wrappedIndex);
            
            // Instant jump
            track.style.scrollBehavior = 'auto';
            allSlides[finalTargetIndex].scrollIntoView({ behavior: "auto", inline: "start", block: "nearest" });
            
            // Update state
            lastScrollLeft = track.scrollLeft;
            
            // Cleanup
            setTimeout(() => {
              track.style.scrollBehavior = '';
              isRepositioning = false;
              isTransitioning = false; 
              // Important: clear transitioning flag after jump
            }, 50);
          }, 550); // Slightly longer than transition
        } else {
          setTimeout(() => {
            isTransitioning = false;
          }, smooth ? 500 : 0);
        }
      };

      // Arrow handlers
      prevBtn.onclick = () => {
        goTo(realIndex - 1);
      };
      
      nextBtn.onclick = () => {
        goTo(realIndex + 1);
      };

      // Handle infinite loop logic for manual scrolling (touch/swipe)
      let scrollTimeout: NodeJS.Timeout;
      
      track.addEventListener("scroll", () => {
        const currentScrollLeft = track.scrollLeft;
        lastScrollLeft = currentScrollLeft;
        
        if (isTransitioning || isRepositioning) return;
        
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          const trackLeft = track.getBoundingClientRect().left;
          let closestSlide = null;
          let closestDist = Infinity;
          let closestIndex = 0;

          allSlides.forEach((slide, i) => {
            const rect = slide.getBoundingClientRect();
            const dist = Math.abs(rect.left - trackLeft);
            if (dist < closestDist) {
              closestDist = dist;
              closestSlide = slide;
              closestIndex = i;
            }
          });

          if (closestSlide && closestDist < 20) { // Tolerance
            const slide = closestSlide as HTMLElement;
            const isFirstClone = slide.getAttribute("data-clone") === "first";
            const isLastClone = slide.getAttribute("data-clone") === "last";
            
            if (isFirstClone) {
                // We are at the end (first clone), jump to start (real first)
                isRepositioning = true;
                const targetIndex = getSlideIndex(0);
                track.style.scrollBehavior = 'auto';
                allSlides[targetIndex].scrollIntoView({ behavior: "auto", inline: "start", block: "nearest" });
                realIndex = 0;
                updateUI();
                setTimeout(() => { track.style.scrollBehavior = ''; isRepositioning = false; }, 50);
            } else if (isLastClone) {
                // We are at the start (last clone), jump to end (real last)
                isRepositioning = true;
                const targetIndex = getSlideIndex(total - 1);
                track.style.scrollBehavior = 'auto';
                allSlides[targetIndex].scrollIntoView({ behavior: "auto", inline: "start", block: "nearest" });
                realIndex = total - 1;
                updateUI();
                setTimeout(() => { track.style.scrollBehavior = ''; isRepositioning = false; }, 50);
            } else {
               const newRealIndex = getRealIndex(closestIndex);
               if (newRealIndex !== realIndex) {
                   realIndex = newRealIndex;
                   updateUI();
               }
            }
          }
        }, 100);
      });

      // Initialize
      initializeCarousel();
      
      // Auto Resize Logic
      const setUniformHeights = () => {
        const testimonialBoxes = document.querySelectorAll(".testimonial-box");
        if (testimonialBoxes.length === 0) return;

        testimonialBoxes.forEach((box) => {
          (box as HTMLElement).style.height = "auto";
        });

        let maxHeight = 0;
        testimonialBoxes.forEach((box) => {
          const height = (box as HTMLElement).offsetHeight;
          if (height > maxHeight) maxHeight = height;
        });

        testimonialBoxes.forEach((box) => {
          (box as HTMLElement).style.height = `${maxHeight}px`;
        });
      };

      setTimeout(setUniformHeights, 100);
      let resizeTimeout: NodeJS.Timeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(setUniformHeights, 250);
      });
    };

    // Run on initial load
    initCarousel();
    
    // Support View Transitions if enabled in future
    document.addEventListener('astro:after-swap', initCarousel);
  </script>

  <style>
    /* Testimonial box styling for uniform height */
    #testimonials .testimonial-box {
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      min-height: 400px; /* Minimum height */
      display: flex;
      flex-direction: column;
    }

    /* Ensure text wraps properly and doesn't create excessive width */
    #testimonials p {
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      text-align: center;
    }

    /* Content wrapper with overflow handling */
    .testimonial-content-wrapper {
      position: relative;
      min-height: 0; /* Allow flex shrinking */
      flex: 1 1 auto;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* Text content area */
    .testimonial-text {
      flex: 0 1 auto;
      text-align: center;
      width: 100%;
    }

    /* Smooth transition for expandable content */
    .testimonial-expanded {
      animation: fadeIn 0.3s ease-in;
      flex: 0 1 auto;
      text-align: center;
      width: 100%;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Footer section styling - always at bottom */
    .testimonial-footer {
      flex-shrink: 0;
      margin-top: auto;
      padding-top: 1.5rem;
      border-top: 1px solid #d1d5db;
    }
  </style>
</section>
